% This is sigproc-sp.tex -FILE FOR V2.6SP OF ACM_PROC_ARTICLE-SP.CLS
% OCTOBER 2002
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V2.6SP
% LaTeX2e document class file for Conference Proceedings submissions.
% 
%----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.6SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
%
%  However, both the CopyrightYear (default to 2002) and the ACM Copyright Data
% (default to X-XXXXX-XX-X/XX/XX) can still be over-ridden by whatever the author
% inserts into the source .tex file.
% e.g.
% \CopyrightYear{2003} will cause 2003 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
%
%---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@acm.org 
%
% For tracking purposes - this is V2.6SP - OCTOBER 2002


\documentclass[12pt]{article}

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textwidth}{6in}
\setlength{\textheight}{9in}
\setlength{\parindent}{0in} 

\usepackage{graphicx} %For jpg figure inclusion
\usepackage{times} %For typeface
\usepackage{epsfig}
\usepackage{color} %For Comments
%\usepackage[all]{xy}
\usepackage{float}
%\usepackage{subfigure} 
\usepackage{hyperref}
\usepackage{url}
\usepackage{parskip}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{BlueViolet}{RGB}{138,43,226}
\definecolor{Coquelicot}{RGB}{255, 56, 0}
\definecolor{Teal}{RGB}{2,132,130}
%Uncomment this if you want to show work-in-progress comments
%\newcommand{\comment}[1]{{\bf \tt  {#1}}}
% Uncomment this if you don't want to show comments
\newcommand{\comment}[1]{}
\newcommand{\emcomment}[1]{\textcolor{ForestGreen}{\comment{Elena: {#1}}}}
\newcommand{\todo}[1]{\textcolor{blue}{\comment{To Do: {#1}}}}
\newcommand{\tscomment}[1]{\textcolor{Teal}{\comment{Tony: {#1}}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\pagestyle{plain}
%
% --- Author Metadata here ---
%\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\setpagenumber{50}
%\CopyrightYear{2002} % Allows default copyright year (2002) to be
%over-ridden - IF NEED BE. 
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data
%(X-XXXXX-XX-X/XX/XX) to be over-ridden. 
% --- End of Author Metadata ---

\title{Improving Clojure Error Messages for Programming Novices with clojure.spec}
%\subtitle{[Extended Abstract \comment{DO WE NEED THIS?}]
%\titlenote{}}
%
% You need the command \numberofauthors to handle the "boxing"
% and alignment of the authors under the title, and to add
% a section for authors number 4 through n.
%
% Up to the first three authors are aligned under the title;
% use the \alignauthor commands below to handle those names
% and affiliations. Add names, affiliations, addresses for
% additional authors as the argument to \additionalauthors;
% these will be set for you without further effort on your
% part as the last section in the body of your article BEFORE
% References or any Appendices.

\author{
Tony Song and Elena Machkasova \\
Computer Science Discipline \\
University of Minnesota Morris\\
Morris, MN 56267\\
songx823@morris.umn.edu, elenam@morris.umn.edu
}
\date{}
\maketitle
\thispagestyle{empty}
%\alcomment{Should these say @morris.umn.edu?}

\section*{\centering Abstract}
Functional programming paradigms have been getting mainstream attention recently because of its elegant concurrency 
handling and conciseness of source code. To introduce functional programming and teach the basic principles of Computer 
Science, a language system based on the Racket programming language in the Lisp family is currently used in an introductory 
Computer Science class at the University of Minnesota, Morris. Even though the current Racket based environment is a 
beginner friendly system with stepwise modes for different levels of learners, it is not widely used in the industry and 
students often have difficulties in transitioning from Racket to Java which is used in mid and upper level Computer Science 
classes at UMM. To solve those issues, a research group at UMM has been working on making a beginner friendly environment 
of the Clojure programming language, which is also in the Lisp family like Racket, to use the language in the introductory 
Computer Science class.

%We decided to use Clojure in lieu of Racket since it is a functional programming language that has quickly gained popularity 
%in the industry and it primarily runs on the Java Virtual Machine. Students can benefit from a large amount of Clojure 
%resources and the big developer community. One challenge that the project tries to deal with is its error messages. 
%Compared to Racketâ€™s plain English error messages, Clojure has less user friendly error messages with many Java terms, 
%which often scare programming novices. Thus, our research team has been focusing on improving Clojure error messages for 
%the last few years. To improve error messages, it is essential to collect more data such as failing values and line number so 
%that our system can provide more useful and informative error messages instead of letting users parse information from 
%stack trace. Clojure.spec is a newly introduced core library of Clojure that allows developers to specify conditions for function 
%inputs and data. If the condition fails, clojure.spec constructs a very informative error message. Using clojure.spec is a 
%substantial improvement over our previous system, which had to keep track of extra information manually since there was no 
%embedded Clojure feature for it. The acquired information from clojure.spec can directly be used to improve error messages 
%after some processing. The paper will show how we use clojure.spec to collect and display the right information and 
%demonstrates the resulting error messages.


\newpage
\setcounter{page}{1}

\section{Introduction}
TBD

\section{Background}
	This section is an introduction to Clojure and the clojure.spec library. 
	\subsection{Clojure}
	Unlike popular mainstream languages such as Java or C++, Clojure shares some distinct features with other LISP dialects. 
	One is the use of parentheses in syntax. In Clojure, every instruction or expression is enclosed by parentheses. To invoke a 
	function, you need to specify a function name right after the opening parenthesis and then list all arguments before the 
	closing parenthesis. Parentheses are required even functions that do not take any arguments. This form of notation is 
	called prefix-notation which is also a feature of Clojure. A simple addition of 3 and 4 in Clojure looks like: 
	\begin{verbatim}
	(+ 3 4)
	\end{verbatim}
	This syntax might look odd, but it is very powerful and easy to parse for machines since the system does not need to 
	calculate operator precedence. 

	Another functional programming feature that Clojure adopted is immutable data structures. In Clojure, once you bind a 
	name to a value, you cannot change the associated value. We call the name of the binding as symbol. To change the 
	binding value, you need to re-define the constant with the same symbol which is essentially a different binding. This is 
	the main source of confusion for developers from object oriented programming background since they are used to 
	change values of a variable. One huge benefit of using immutable data types is minimizing side effects, which means 
	developers do not need to worry about variables being modified from unanticipated places.

	Among various data structures that Clojure supports, an abstract sequential data type called sequences is very unique in 
	a way they behave; a sequence can be lazy. A sequence being lazy means the element(s) of them can potentially be realized even though they do not exist now. 
	In other words, a lazy sequence is like a set of rules that is able to generate elements according to them.
	They just exist as a type until some functions force the lazy sequence to be evaluated. Because of its laziness, it is possible 
	for a lazy sequence to represent an infinite value. The following is a function that returns a lazy sequence that stores the 
	Fibonacci sequence when the starting values are n1 and n2. Theoretically, it can generate elements of the Fibonacci 
	sequence infinitely. 
	\begin{verbatim}
	(defn fibonacci [n1 n2]
		(lazy-seq (cons n1 (fibonacci n2 (+ n1 n2))))
	\end{verbatim}

	
	\subsection{Introduction to clojure.spec}
	The newly introduced cloure.spec library is a contract system that allows Clojure developers to specify and validate expected data 
	types at runtime. In addition to data validation, clojure.spec provides errors that are easy to parse. Each spec is just a 				 
	specification for data, so any predicate functions can be used as spec predicates. \texttt{s/def} is used to define specs. Following are 
	some simple spec definitions with Clojure predicates:
	\begin{verbatim}
	(s/def ::check-int integer?)
	(s/def ::check-function ifn?)
	\end{verbatim}
	It is possible to assemble simple specs to create a more complicated spec. For instance, we can write a spec that verifies 
	the argument types of a function by combining \texttt{::check-int} and \texttt{::check-function} with \texttt{s/cat}. 
	\begin{verbatim}
	(s/def ::check-int-function 
	(s/cat :first-arg ::check-int
    	:second-arg ::check-function))
	\end{verbatim}
	One really powerful feature of spec is the use of regular operators such as \texttt{s/cat}, \texttt{s/*}, and \texttt{s/?}. Using 
	these regular operators, we can describe a variety of data structures, including lazy sequences and nested data. To define 
	input and output specifications for functions, clojure.spec uses \texttt{s/fdef}. Even though it is possible to define the output spec 
	for a function, it is only usable in spec testing. For our purpose, we will be focused on the input verification. Let's take a 
	look at an example of using \texttt{s/fdef}. Following are a simplified definition of \texttt{even?} function and a possible function spec for it. 
	One thing to keep in mind is that you should turn on the spec to start checking data. Otherwise, the spec is completely 
	ignored at runtime.
	\begin{verbatim}
	(defn even? [n] (= (mod n 2) 0))
	(s/fdef even?
    	:args (s/cat ::check-int integer?))
	;; turn on the function spec
	(stest/instrument 'name-space/even?)
	\end{verbatim}
	
	


\section{Clojure error messages}
TBD

\section{Improving error messages with clojure.spec}
TBD

\section{Conclusions and future work}
	\subsection{Conclusions}
	\subsection{Future work}
	
\bibliographystyle{acm}
\bibliography{mics2017}

% \section{References?}\label{sec:reference}
% \escomment{unsure if we actually put references directly into the
%   paper or not...}
% \emcomment{Emma - Don't worry about it for now. Do you have a reference you
%   would like to add?}
% \escomment{I have a few links to websites I used, but I'm not sure what format I should use for preparing them properly}

% That's all folks!
\end{document}
