% This is sigproc-sp.tex -FILE FOR V2.6SP OF ACM_PROC_ARTICLE-SP.CLS
% OCTOBER 2002
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V2.6SP
% LaTeX2e document class file for Conference Proceedings submissions.
% 
%----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.6SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
%
%  However, both the CopyrightYear (default to 2002) and the ACM Copyright Data
% (default to X-XXXXX-XX-X/XX/XX) can still be over-ridden by whatever the author
% inserts into the source .tex file.
% e.g.
% \CopyrightYear{2003} will cause 2003 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
%
%---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@acm.org 
%
% For tracking purposes - this is V2.6SP - OCTOBER 2002


\documentclass[12pt]{article}

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textwidth}{6in}
\setlength{\textheight}{9in}
\setlength{\parindent}{0in} 

\usepackage{graphicx} %For jpg figure inclusion
\usepackage{times} %For typeface
\usepackage{epsfig}
\usepackage{color} %For Comments
%\usepackage[all]{xy}
\usepackage{float}
%\usepackage{subfigure} 
\usepackage{hyperref}
\usepackage{url}
\usepackage{parskip}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{BlueViolet}{RGB}{138,43,226}
\definecolor{Coquelicot}{RGB}{255, 56, 0}
\definecolor{Teal}{RGB}{2,132,130}
%Uncomment this if you want to show work-in-progress comments
\newcommand{\comment}[1]{{\bf \tt  {#1}}}
% Uncomment this if you don't want to show comments
%\newcommand{\comment}[1]{}
\newcommand{\emcomment}[1]{\textcolor{ForestGreen}{\comment{Elena: {#1}}}}
\newcommand{\todo}[1]{\textcolor{blue}{\comment{To Do: {#1}}}}
\newcommand{\tscomment}[1]{\textcolor{Teal}{\comment{Tony: {#1}}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\pagestyle{plain}
%
% --- Author Metadata here ---
%\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\setpagenumber{50}
%\CopyrightYear{2002} % Allows default copyright year (2002) to be
%over-ridden - IF NEED BE. 
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data
%(X-XXXXX-XX-X/XX/XX) to be over-ridden. 
% --- End of Author Metadata ---

\title{Improving Clojure Error Messages for Programming Novices with clojure.spec}
%\subtitle{[Extended Abstract \comment{DO WE NEED THIS?}]
%\titlenote{}}
%
% You need the command \numberofauthors to handle the "boxing"
% and alignment of the authors under the title, and to add
% a section for authors number 4 through n.
%
% Up to the first three authors are aligned under the title;
% use the \alignauthor commands below to handle those names
% and affiliations. Add names, affiliations, addresses for
% additional authors as the argument to \additionalauthors;
% these will be set for you without further effort on your
% part as the last section in the body of your article BEFORE
% References or any Appendices.

\author{
Tony Song and Elena Machkasova \\
Computer Science Discipline \\
University of Minnesota Morris\\
Morris, MN 56267\\
songx823@morris.umn.edu, elenam@morris.umn.edu
}
\date{}
\maketitle
\thispagestyle{empty}
%\alcomment{Should these say @morris.umn.edu?}

\section*{\centering Abstract}
Functional programming paradigms have been getting mainstream attention recently because of its elegant concurrency 
handling and conciseness of source code. To introduce functional programming and teach the basic principles of Computer 
Science, a language system based on the Racket programming language in the Lisp family is currently used in an introductory 
Computer Science class at the University of Minnesota, Morris. Even though the current Racket based environment is a 
beginner friendly system with stepwise modes for different levels of learners, it is not widely used in the industry and 
students often have difficulties in transitioning from Racket to Java which is used in mid and upper level Computer Science 
classes at UMM. To solve those issues, a research group at UMM has been working on making a beginner friendly environment 
of the Clojure programming language, which is also in the Lisp family like Racket, to use the language in the introductory 
Computer Science class.

%We decided to use Clojure in lieu of Racket since it is a functional programming language that has quickly gained popularity 
%in the industry and it primarily runs on the Java Virtual Machine. Students can benefit from a large amount of Clojure 
%resources and the big developer community. One challenge that the project tries to deal with is its error messages. 
%Compared to Racketâ€™s plain English error messages, Clojure has less user friendly error messages with many Java terms, 
%which often scare programming novices. Thus, our research team has been focusing on improving Clojure error messages for 
%the last few years. To improve error messages, it is essential to collect more data such as failing values and line number so 
%that our system can provide more useful and informative error messages instead of letting users parse information from 
%stack trace. Clojure.spec is a newly introduced core library of Clojure that allows developers to specify conditions for function 
%inputs and data. If the condition fails, clojure.spec constructs a very informative error message. Using clojure.spec is a 
%substantial improvement over our previous system, which had to keep track of extra information manually since there was no 
%embedded Clojure feature for it. The acquired information from clojure.spec can directly be used to improve error messages 
%after some processing. The paper will show how we use clojure.spec to collect and display the right information and 
%demonstrates the resulting error messages.


\newpage
\setcounter{page}{1}

\section{Introduction}
TBD

\section{Background}
	This section is an introduction to Clojure and the clojure.spec library. 
	\subsection{Clojure}
	Unlike popular mainstream languages such as Java or C++, Clojure shares some distinct features with other LISP dialects. 
	\emcomment{This is an awkward sentence, rewrite? }
	One is the use of parentheses in syntax. In Clojure, every instruction or expression is enclosed in parentheses. To invoke a 
	function, you need to specify a function name right after the opening parenthesis and then list all arguments before the 
	closing parenthesis. Parentheses are required even for functions that do not take any arguments. This form of notation is 
	called prefix-notation which is also a feature of Clojure. A simple addition of 3 and 4 in Clojure looks like: 
	\begin{verbatim}
	(+ 3 4)
	\end{verbatim}
	This syntax might look odd, but it is very powerful and easy to parse for machines since the system does not need to 
	calculate operator precedence. \emcomment{Mention that + is a function; the syntax is also convenient since it easily accommodates a variable number of arguments}

	Another functional programming feature that Clojure adopted is immutable data structures. In Clojure, once you bind a 
	name to a value, you cannot change the associated value. We call the name of the binding as symbol. To change the 
	binding value, you need to re-define the constant with the same symbol which is essentially a different binding. 
	\emcomment{I would remove the previous two sentences: don't need this level of detail. }
	This is 
	the main source of confusion for developers from object oriented programming background since they are used to 
	change values of a variable. One huge benefit of using immutable data types is minimizing side effects, which means 
	developers do not need to worry about variables being modified from unanticipated places.

	Among various data structures that Clojure supports, an abstract sequential data type called sequences is very unique in 
	a way they behave; a sequence can be lazy. A sequence being lazy means that its element(s) can potentially be realized even though they do not exist now. 
	\emcomment{This is very confusing! Unclear what "realize" means. }
	In other words, a lazy sequence is like a set of rules that is able to generate elements according to them.
	Such sequences just exist as a type until some functions force them to be evaluated. Because of its laziness, it is possible 
	for a lazy sequence to represent an infinite value. The following is a function that returns a lazy sequence that stores the 
	Fibonacci sequence when the starting values are n1 and n2. Theoretically, it can generate elements of the Fibonacci 
	sequence infinitely. 
	\begin{verbatim}
	(defn fibonacci [n1 n2]
	   (lazy-seq (cons n1 (fibonacci n2 (+ n1 n2))))
	\end{verbatim}
	\emcomment{You need to introduce a bit of Clojure syntax for a function definition, you can't just jump to this.}
	
	\subsection{Introduction to clojure.spec}
	The newly introduced cloure.spec library is a contract system that allows Clojure developers to specify and validate expected data 
	types \emcomment{I'd say, expected data, not (just) data types} at runtime. In addition to data validation, clojure.spec provides errors that are easy to parse. Each spec is just a 				 
	specification for data, so any predicate functions can be used as spec predicates. \texttt{s/def} is used to define specs. Following are 
	some simple spec definitions with Clojure predicates:
	\begin{verbatim}
	(s/def ::check-int integer?)
	(s/def ::check-function ifn?)
	\end{verbatim}
	It is possible to assemble simple specs to create a more complicated spec. For instance, we can write a spec that verifies 
	the argument types of a function by combining \texttt{::check-int} and \texttt{::check-function} with \texttt{s/cat} 
	which stands for concatenation. 
	\begin{verbatim}
	(s/def ::check-int-function 
	(s/cat :first-arg ::check-int
    	:second-arg ::check-function))
	\end{verbatim}
	\emcomment{show what the above example validates: what data is valid? }
	One really powerful feature of spec is the use of regular operators such as \texttt{s/cat}, \texttt{s/*}, and \texttt{s/?}. 
	\emcomment{Mention what the other two stand for.}
	Using 
	these regular operators, we can describe a variety of data structures, including lazy sequences and nested data. 

	To define 
	input and output specifications for functions, clojure.spec uses \texttt{s/fdef}. Even though it is possible to define the output spec 
	for a function, it is only usable in spec testing. For our purpose, we will be focused on the input verification. Let's take a 
	look at an example of using \texttt{s/fdef}. Following are a simplified definition of \texttt{even?} function and a possible function spec for it. 
	\emcomment{Move the two following sentences elsewhere (you can talk about instrumenting at the beginning or the end of the section)}
	One thing to keep in mind is that you should turn on the spec to start checking data. Otherwise, the spec is completely 
	ignored at runtime.
	\begin{verbatim}
	(defn even? [n] (= (mod n 2) 0))
	(s/fdef even?
    	:args (s/cat ::check-int integer?))
	;; turn on the function spec
	(stest/instrument 'name-space/even?)
	\end{verbatim}
	
	


\section{Clojure error messages}
\subsection{Overview of Clojure error messages and our approaches}
Since Clojure compiles to Java bytecodes and runs on the JVM, Clojure error messages are just Java exceptions
and uses Java datatypes and terminology. 
For instance, {\tt (+ 2 true)} is an attempt to add a number and a boolean. 
Since Java does not automatically convert booleans to numbers, this code results in an error:
\begin{verbatim}
ClassCastException java.lang.Boolean cannot be cast 
to java.lang.Number  
clojure.lang.Numbers.add (Numbers.java:128)
\end{verbatim} 
This is quite cryptic for beginners since they are not familiar with a term ``class'' for a datatype,
``casting'' for type conversion, and ``exception'' for an error. Moreover, even if a term ``boolean'' 
has been introduced to them for true/false values, the prefix {\tt  java.lang} does not 
correspond to their experience. Also, note that the class {\tt Number} has a prefix {\tt  clojure.lang}
which is different from {\tt  java.lang} . To worsen the confusion, instead of referring
to the function {\tt +}, the error message refers to the method {\tt add}, and the class 
in which it is defined is {\tt clojure.lang.Numbers}. Those familiar with Java may identify this
method as a static method (mostly based on the naming convention: {\tt Numbers} is pluralized). 
For new Clojure programmers not familiar with Java, however, the message carries very little, if any, information. 
Even if these new programmers memorize common error messages terminology after a while, 
it would still not have any grounding in their experience. 

Clearly, this situation is not acceptable in an introductory computer science class. Thus, one of the directions of our project is to 
provide a set of error messages that would be more consistent and meaningful in the context of 
novice programmers experience. 

Our error messages translate standard Clojure error messages into terms that are less confusing for beginners. 
For example, the above-mentioned expression  {\tt (+ 2 true)} would result in the error message
\begin{verbatim}
In function "+" the second argument "true" must be a number, 
but is a boolean. 
\end{verbatim} 
In this error message it is clear what function is being called, which argument is causing a problem, 
what is expected, and what is given. 

Our approach to replacing standard error messages has two main cases and a default case:
\begin{enumerate}
\item For commonly used functions we provide a direct assertion to check if we are passing the right number and types 
of parameters, and report an error if we do not. These errors are more informative than default errors.
\item For other cases we perform a lookup of an error message in our ``dictionary'' using pattern-matching, 
and replace the wording so that it is more understandable to beginners. 
\item For rare cases that are not listed in the dictionary we have no choice but to report an error as it is. 
\end{enumerate}
For this paper we are focusing on the first case: providing an assertion to check the number and type of the
arguments. We discuss how we have been handling this situation in the past and how using clojure.spec 
allows us to collect the same information as before (and sometimes more) in a way that is less error-prone. 

\subsection{Assertions for common Clojure functions}
The approach to providing assertions to check function arguments that we used prior to 
incorporating clojure.spec was to write our own function with the same name as a standard one, 
provide a precondition for it to check if the arguments are valid, and if they are, call 
the function provided by core Clojure. Here is an example of this approach used for
function {\tt +} that specifies that it can take any number of arguments, but all
of these arguments must be numbers:
\begin{verbatim}
(defn + [& args]
   {:pre [(check-if-numbers? "+" args 1)]}
   (apply clojure.core/+ args))
\end{verbatim} 
In this example:
\begin{itemize}
\item the name of the function is {\tt +}, 
\item the {\tt [\& args]} is the arguments list. The {\tt \&} sign indicates that what follows is
a list of arguments of arbitrary length. 
\item The next line (with {\tt :pre} in curly braces) is the precondition, followed by a list
(in square brackets) of conditions to check. 
\item In this case there is only one condition to check. It is given by our own 
function {\tt check-if-numbers?} 
and passing to it {\tt args} (the arguments passed to {\tt +}, the name of the function we 
are checking, which is "+", and the starting number of the arguments being checked 
(in this case we are checking all of the arguments, so the starting number is {\tt 1}). 
\item  If {\tt check-if-numbers?}  returns true, the body of the overwritten function {\tt +} 
gets executed. If it return false, an assertion error is thrown by the precondition. 
\item The last line {\tt  (apply clojure.core/+ args)} applies the {\tt +} function in 
{\tt clojure.core} to the list of arguments. One can think of {\tt  clojure.core/+} as 
a path to the function {\tt +} in the core package of Clojure. 
\end{itemize}

\emcomment{walk through step-by-step with an example (correct data and incorrect data); 
show what information gets recorded in an atom, show the resulting error message}

\emcomment{Mention challenges and limitations - here or elsewhere? In conclusions? 
This doesn't seem to be a good place}

\section{Improving error messages with clojure.spec}
	\subsection{Benefits of using clojure.spec}
	If a non-spec function fails, it throws an error having the information about the type of error, error message, and stack 
	trace. The failing value is rarely given in the error. Even when it is given, you still need to parse the specific value out of 
	the error message string. The same problem occurs when it comes to the line number indicating where it failed. 
	Because an accurate line number is not given in the error message, users need to go through the stack trace to find 
	where the error actually happened. On the other hand, if a function with a spec fails, an exception object {\tt 
	clojure.lang.ExceptionInfo} is thrown. This exception object has a hash map of failure information, which can easily be 
	parsed with Clojure {\tt ex-data} function. 

	One prerequisite to provide user-friendly error messages is having enough information about the function failure. Since 
	default Clojure error does not provide sufficient data such as the name of failing function or the failing value, our 
	research group had to use some sort of global state to store extra information. With clojure.spec, we no longer need a 
	global variable because the hash map of {\tt clojure.lang.ExeptoinInfo} object has much more information about the 
	failure compared to the default Clojure error. The information that the hash map provides contains which predicate it 
	failed, which the failing value was, and where the value was in the argument sequence if the function takes multiple 
	arguments. In addition, they can be easily parsed as we explained earlier.
	
	\subsection{Approaches to improve error messages}
	With clojure.spec, we have used two different approaches to improve error messages. One way is using a function spec. 
	If we write function specs that are attached to the Clojure core functions, the spec error is thrown when some function 
	call fails. Then, we can parse the spec error and process it before we show them to the user. For instance, min function 
	takes one or more numbers, and returns the least number. We can verify the input of the min function by providing a 
	function spec like following:

	\begin{verbatim}
	(s/fdef clojure.core/min
	:args (s/cat :check-numbers (s/+ number?)))
	\end{verbatim}

	The main advantage of using a function spec is that we do not need to overwrite core functions. We attach our 
	function specs to the Clojure core functions and simply turn on the spec checking. It is also very flexible because we 
	can turn on and off the spec checking. We eventually decided to use the second approach, using spec assert, after we 
	discovered some issues with the function spec. Function specs do not work for inline functions. Many of Clojure core 
	arithmetic functions are inline functions for better performance. Beginners often use arithmetic functions, including +, -, 
	or *, so not using specs for them is a huge downside. Also, function specs seem to have some problems dealing with 
	lazy sequences. 

	\todo{s/spec overwrites Clojure functions. But they seem promising (no inline or lazy-seq issue)}

\section{Conclusions and future work}
	\subsection{Conclusions}
	\subsection{Future work}
\emcomment{Figure out what to do with transducers}
	
\bibliographystyle{acm}
\bibliography{mics2017}

\end{document}
